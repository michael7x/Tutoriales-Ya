<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/html4/loose.dtd"> 
<html>


<!-- Mirrored from www.javaya.com.ar/detalleconcepto.php?codigo=115&inicio=40 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 15 Sep 2015 14:54:04 GMT -->
<head>
<title>Estructuras dinámicas: Listas tipo Pila</title>
<meta name="viewport" content="width=device-width, initial-scale=1">    
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="tutorial java">
<meta name="description" content="Tutorial de Java">
<link href="css/estilos.css" rel="stylesheet" type="text/css">
<style>
html,body {
	background-color: #D3E9D0;
	font-family: Arial, sans-serif;
	font-size: 11pt;
	text-align:center;
}

h1 {
	margin: 0%;
}

.recuadro {
  background-color:#ffffcc;
  text-align:left;
  font-family:courier;
  font-size:1.2em;
  border-width:0;
  padding:5px;

  border: 1px dotted #ffaa00;
}

.recuadroborde {
    max-height: 400pt;
	overflow: auto;
    font-family: consolas, monospace;
    font-size: 12pt;
    margin-left: 1%;
    margin-right: 1%;
    background-color:#ffffcc;	
    padding: 7px;
    border: 2px ridge black;
    border-radius: 7px;
}

pre {
 	overflow: auto;
    font-family: consolas, monospace;
    font-size: 12pt;
    margin-left: 1%;
    margin-right: 1%;
    background-color: #aed7a8;
    padding: 7px;
    border: 0px;
}

.recuadrooculto {
  background-color:#ffffcc;
  text-align:left;
  font-family:courier;

  border-width:0;
  padding:5px;

  border: 1px dotted #ffaa00;
  display: none;
}

 img {
   padding:11px;
 }
 
 li {
    padding:10px;
 }
 
  
</style>

<script type="text/javascript">
function cambiar()
{
  var lista=document.getElementsByTagName('pre');
  for(f=0;f<lista.length;f++)
  {
   lista[f].style.display='block';
  }
  document.getElementById('solucion').style.display='none';
}

</script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-628756-28']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>

<div class="upperleft">
  <div class="upperright">
    <div class="lowerleft">
      <div class="lowerright">
<table width="98%">
<tr>
<td> 
<h1> - Estructuras dinámicas: Listas tipo Pila</h1></td>
<td align="right">

</td>
</tr>
</table>

      </div>
    </div>
  </div>
</div>
<br>


<div class="upperleft">
  <div class="upperright">
    <div class="lowerleft">
      <div class="lowerright">
 <div id="contentdetalle">

<div style="display:block;float:left;margin: 5px;"> 
 
<script async src="../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
<!-- propuesto-javaya -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-4669394804436935"
     data-ad-slot="1400020364"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
 
</div> 

<p>Una lista se comporta como una pila si las inserciones y extracciones las hacemos por un mismo lado de la lista. También se las llama listas LIFO (Last In First Out - último en entrar primero en salir)</p>

<p><strong>Importante</strong>: Una pila al ser una lista puede almacenar en el campo de información cualquier tipo de valor (int, char, float, vector de caracteres, un objeto, etc)</p>

<p>Para estudiar el mecanismo de utilización de una pila supondremos que en el campo de información almacena un entero (para una fácil interpretación y codificación)</p>

<p>Inicialmente la PILA está vacía y decimos que el puntero raiz apunta a null (Si apunta a null decimos que no tiene una dirección de memoria):</p>
<img src="imagentema/foto084.jpg" border="0" alt="pila vacía"><br>

<p>Insertamos un valor entero en la pila: insertar(10)</p>
<img src="imagentema/foto087.jpg" border="0" alt="pila"><br>

<p>Luego de realizar la inserción la lista tipo pila queda de esta manera: un nodo con el valor 10 y raiz apunta a dicho nodo. El puntero del nodo apunta a null ya que no hay otro nodo después de este.</p>


<p>Insertamos luego el valor 4: insertar(4)</p>
<img src="imagentema/foto088.jpg" border="0" alt="pila"><br>

<p>Ahora el primer nodo de la pila es el que almacena el valor cuatro. raiz apunta a dicho nodo. Recordemos que raiz es el puntero externo a la lista que almacena la dirección del primer nodo.
El nodo que acabamos de insertar en el campo puntero guarda la dirección del nodo que almacena el valor 10.</p>


<p>Ahora qué sucede si extraemos un nodo de la pila. ¿Cuál se extrae? Como sabemos en una pila se extrae el último en entrar.</p>

<p>Al extraer de la pila tenemos: extraer()</p>
<img src="imagentema/foto089.jpg" border="0" alt="pila"><br>

<p>La pila ha quedado con un nodo.<br>

Hay que tener cuidado que si se extrae un nuevo nodo la pila quedará vacía y no se podrá extraer otros valores (avisar que la pila está vacía)</p>


<h3>Problema 1:</h3>
<p>Confeccionar una clase que administre una lista tipo pila (se debe poder insertar, extraer e imprimir los datos de la pila)</p>
<h4>Programa:</h4>
<pre class="recuadro">
public class Pila {
	
    class Nodo {
        int info;
        Nodo sig;
    }
	
    private Nodo raiz;
    
    public Pila () {
        raiz=null;
    }
    
    public void insertar(int x) {
    	Nodo nuevo;
        nuevo = new Nodo();
        nuevo.info = x;
        if (raiz==null)
        {
            nuevo.sig = null;
            raiz = nuevo;
        }
        else
        {
            nuevo.sig = raiz;
            raiz = nuevo;
        }
    }
    
    public int extraer ()
    {
        if (raiz!=null)
        {
            int informacion = raiz.info;
            raiz = raiz.sig;
            return informacion;
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
    
    public void imprimir() {
        Nodo reco=raiz;
        System.out.println("Listado de todos los elementos de la pila.");
        while (reco!=null) {
            System.out.print(reco.info+"-");
            reco=reco.sig;
        }
        System.out.println();
    }
    
    public static void main(String[] ar) {
        Pila pila1=new Pila();
        pila1.insertar(10);
        pila1.insertar(40);
        pila1.insertar(3);
        pila1.imprimir();
        System.out.println("Extraemos de la pila:"+pila1.extraer());
        pila1.imprimir();        
    }
}
</pre>


<p>Analicemos las distintas partes de este programa:</p>
<pre>
    class Nodo {
        int info;
        Nodo sig;
    }
	
    private Nodo raiz;
</pre>

<p>Para declarar un nodo debemos utilizar una clase. En este caso la información del nodo (info) es un entero y siempre el nodo tendrá una referencia de tipo Nodo, que le llamamos sig.<br>
El puntero sig apunta al siguiente nodo o a null en caso que no exista otro nodo. Este puntero es interno a la lista.<br>
También definimos un puntero de tipo Nodo llamado raiz. Este puntero tiene la dirección del primer nodo de la lista. En caso de estar vacía la lista, raiz apunta a null (es decir no tiene dirección)</p>

<p>El puntero raiz es fundamental porque al tener la dirección del primer nodo de la lista nos permite acceder a los demás nodos.</p>
<pre>
    public Pila () {
        raiz=null;
    }
</pre>
<p>En el constructor de la clase hacemos que raiz guarde el valor null. Tengamos en cuenta que si raiz tiene almacenado null la lista está vacía, en caso contrario tiene la dirección del primer nodo de la lista.</p>

<pre>
    public void insertar(int x) {
    	Nodo nuevo;
        nuevo = new Nodo();
        nuevo.info = x;
        if (raiz==null)
        {
            nuevo.sig = null;
            raiz = nuevo;
        }
        else
        {
            nuevo.sig = raiz;
            raiz = nuevo;
        }
    }
</pre>

<p>Uno de los métodos más importantes que debemos entender en una pila es el de insertar un elemento en la pila.<br>
Al método llega la información a insertar, en este caso en particular es un valor entero.</p>

<p>La creación de un nodo requiere dos pasos:</p>

<p>- Definición de un puntero o referencia a un tipo de dato Nodo:</p>
<pre>
    	Nodo nuevo;
</pre>
</p>- Creación del nodo (creación de un objeto):</p>
<pre>
        nuevo = new Nodo();
</pre>
<p>Cuando se ejecuta el operador new se reserva espacio para el nodo. Realmente se crea el nodo cuando se ejecuta el new.</p>
<img src="imagentema/foto090.jpg" border="0" alt="pila"><br>
<p>Paso seguido debemos guardar la información del nodo:</p>
<pre>
        nuevo.info = x;
</pre>
<p>En el campo info almacenamos lo que llega en el parámetro x. Por ejemplo si llega un 5 el nodo queda:</p>
<img src="imagentema/foto091.jpg" border="0" alt="pila"><br>
<p>Por último queda enlazar el nodo que acabamos de crear al principio de la lista.<br>

Si la lista está vacía debemos guardar en el campo sig del nodo el valor null para indicar que no hay otro nodo después de este, y hacer que raiz apunte al nodo creado (sabemos si una lista esta vacía si raiz almacena un null)</p>
<pre>
        if (raiz==null)
        {
            nuevo.sig = null;
            raiz = nuevo;
        }
</pre>
<img src="imagentema/foto092.jpg" border="0" alt="pila"><br>

<p>Gráficamente podemos observar que cuando indicamos raiz=nuevo, el puntero raiz guarda la dirección del nodo apuntado por nuevo.<br>
Tener en cuenta que cuando finaliza la ejecución del método el puntero nuevo desaparece, pero no el nodo creado con el operador new.</p>

<p>En caso que la lista no esté vacía, el puntero sig del nodo que acabamos de crear debe apuntar al que es hasta este momento el primer nodo, es decir al nodo que apunta raiz actualmente.</p>
<pre>
        else
        {
            nuevo.sig = raiz;
            raiz = nuevo;
        }
</pre>
<p>Como primera actividad cargamos en el puntero sig del nodo apuntado por nuevo la dirección de raiz, y posteriormente raiz apunta al nodo que acabamos de crear, que será ahora el primero de la lista.</p>

<p>Antes de los enlaces tenemos:</p>
<img src="imagentema/foto093.jpg" border="0" alt="pila"><br>

<p>Luego de ejecutar la línea:</p>
<pre>
            nuevo.sig = raiz;
</pre>
<p>Ahora tenemos:</p>
<img src="imagentema/foto094.jpg" border="0" alt="pila"><br>

<p>Por último asignamos a raiz la dirección que almacena el puntero nuevo.</p>
<pre>
            raiz = nuevo;
</pre>

<p>La lista queda:</p>
<img src="imagentema/foto095.jpg" border="0" alt="pila"><br>

<p>El método extraer:</p>
<pre>
    public int extraer ()
    {
        if (raiz!=null)
        {
            int informacion = raiz.info;
            raiz = raiz.sig;
            return informacion;
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
</pre>

<p>El objetivo del método extraer  es retornar la información del primer nodo y además borrarlo de la lista.</p>
<p>Si la lista no está vacía guardamos en una variable local la información del primer nodo:</p>
<pre>
            int informacion = raiz.info;
</pre>
<p>Avanzamos raiz al segundo nodo de la lista, ya que borraremos el primero:</p>
<pre>
            raiz = raiz.sig;
</pre>
<p>el nodo que previamente estaba apuntado por raiz es eliminado automáticamente por la máquina virtual de Java, al no tener ninguna referencia.</p>
<p>Retornamos la información:</p>
<pre>
            return informacion;
</pre>
<p>En caso de estar  vacía la pila retornamos el número entero máximo y lo tomamos como código de error (es decir nunca debemos guardar el entero mayor en la pila)</p>
<pre>
            return Integer.MAX_VALUE;
</pre>


<p>Es muy importante entender gráficamente el manejo de las listas. La interpretación gráfica nos permitirá plantear inicialmente las soluciones para el manejo de listas.</p>
<img src="imagentema/foto096.jpg" border="0" alt="pila"><br>


<p>Por último expliquemos el método para recorrer una lista en forma completa e imprimir la información de cada nodo:</p>
<pre>
    public void imprimir() {
        Nodo reco=raiz;
        System.out.println("Listado de todos los elementos de la pila.");
        while (reco!=null) {
            System.out.print(reco.info+"-");
            reco=reco.sig;
        }
        System.out.println();
    }
</pre>

<p>Definimos un puntero auxiliar reco y hacemos que apunte al primer nodo de la lista:</p>
<pre>
        Nodo reco=raiz;
</pre>
<p>Disponemos una estructura repetitiva que se repetirá mientras reco sea distinto a null. Dentro de la estructura repetitiva hacemos que reco avance al siguiente nodo:</p>
<pre>
        while (reco!=null) {
            System.out.print(reco.info+"-");
            reco=reco.sig;
        }
</pre>

<p>Es muy importante entender la línea:</p>
<pre>
            reco=reco.sig;
</pre>

<p>Estamos diciendo que reco almacena la dirección que tiene el puntero sig del nodo apuntado actualmente por reco.</p>



<p>Gráficamente:</p>
<img src="imagentema/foto097.jpg" border="0" alt="pila"><br>


<p>Al analizarse la condición:</p>
<pre>
        while (reco!=null) {
</pre> 
<p>se valúa en verdadero ya que reco apunta a un nodo y se vuelve a ejecutar la línea:</p>
<pre>
            reco=reco.sig;
</pre>
<p>Ahora reco apunta al siguiente nodo:</p>
<img src="imagentema/foto098.jpg" border="0" alt="pila"><br>

<p>La condición del while nuevamente se valúa en verdadera y avanza el puntero reco al siguiente nodo:</p>
<pre>
            reco=reco.sig;
</pre>
<img src="imagentema/foto099.jpg" border="0" alt="pila"><br>

<p>Ahora sí reco apunta a null y ha llegado el final de la lista (Recordar que el último nodo de la lista tiene almacenado en el puntero sig  el valor null, con el objetivo de saber que es el último nodo)</p>

<p>Para poder probar esta clase recordemos que debemos definir un objeto de la misma y llamar a sus métodos:</p>
<pre>
    public static void main(String[] ar) {
        Pila pila1=new Pila();
        pila1.insertar(10);
        pila1.insertar(40);
        pila1.insertar(3);
        pila1.imprimir();
        System.out.println("Extraemos de la pila:"+pila1.extraer());
        pila1.imprimir();        
    }
</pre>
<p>Insertamos 3 enteros, luego imprimimos la pila, extraemos uno de la pila y finalmente imprimimos nuevamente la pila.</p>

<h3>Problema 2:</h3>
<p>Agregar a la clase Pila un método que retorne la cantidad de nodos y otro que indique si esta vacía.</p>
<h4>Programa:</h4>
<pre class="recuadro">
public class Pila {
	
	class Nodo {
	    int info;
	    Nodo sig;
	}
	
    private Nodo raiz;
    
    Pila () {
        raiz=null;
    }
    
    public void insertar(int x) {
    	Nodo nuevo;
        nuevo = new Nodo();
        nuevo.info = x;
        if (raiz==null)
        {
            nuevo.sig = null;
            raiz = nuevo;
        }
        else
        {
            nuevo.sig = raiz;
            raiz = nuevo;
        }
    }
    
    public int extraer ()
    {
        if (raiz!=null)
        {
            int informacion = raiz.info;
            raiz = raiz.sig;
            return informacion;
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
    
    public void imprimir() {
        Nodo reco=raiz;
        System.out.println("Listado de todos los elementos de la pila.");
        while (reco!=null) {
            System.out.print(reco.info+"-");
            reco=reco.sig;
        }
        System.out.println();
    }
    
    public boolean vacia() {
        if (raiz==null) {
            return true;
        } else {
    	    return false; 
        }
    }
    
    public int cantidad() {
        int cant=0;
        Nodo reco=raiz;
        while (reco!=null) {
            cant++;
            reco=reco.sig;
        }
        return cant;
    }
    
    public static void main(String[] ar) {
        Pila pila1=new Pila();
        pila1.insertar(10);
        pila1.insertar(40);
        pila1.insertar(3);
        pila1.imprimir();
        System.out.println("La cantidad de nodos de la lista es:"+pila1.cantidad());
        while (pila1.vacia()==false) {
            System.out.println(pila1.extraer());
        }
    }
}
</pre>
<p>Para verificar si la pila esta vacía verificamos el contenido de la variable raiz, si tiene null luego la lista esta vacía y por lo tanto retornamos un true:</p>
<pre>
    public boolean vacia() {
        if (raiz==null) {
            return true;
        } else {
    	    return false; 
        }
    }
</pre>
<p>El algoritmo para saber la cantidad de nodos es similar al imprimir, pero en lugar de mostrar la información del nodo procedemos a incrementar un contador:</p>
<pre>
    public int cantidad() {
        int cant=0;
        Nodo reco=raiz;
        while (reco!=null) {
            cant++;
            reco=reco.sig;
        }
        return cant;
    }
</pre>

<p>Para probar esta clase en la main creamos un objeto de la clase Pila insertamos tres enteros:</p>
<pre>
        Pila pila1=new Pila();
        pila1.insertar(10);
        pila1.insertar(40);
        pila1.insertar(3);
</pre>
<p>Imprimimos la pila (nos muestra los tres datos):</p>
<pre>
        pila1.imprimir();
</pre>
<p>Llamamos al método cantidad (nos retorna un 3):</p>
<pre>
        System.out.println("La cantidad de nodos de la lista es:"+pila1.cantidad());
</pre>
<p>Luego mientras el método vacía nos retorne un false (lista no vacía) procedemos a llamar al método extraer:</p>
<pre>
        while (pila1.vacia()==false) {
            System.out.println(pila1.extraer());
        }
</pre>

<h2>Problemas propuestos</h2>
<ol>
<li>
Agregar un método a la clase Pila que retorne la información del primer nodo de la Pila sin borrarlo.</li>
</ol>
<a href="javascript:cambiar()" id="solucion">Solución</a>
<pre class="recuadrooculto">
public class Pila {
	
	class Nodo {
	    int info;
	    Nodo sig;
	}
	
    private Nodo raiz;
    
    Pila () {
        raiz=null;
    }
    
    public void insertar(int x) {
    	Nodo nuevo;
        nuevo = new Nodo();
        nuevo.info = x;
        if (raiz==null)
        {
            nuevo.sig = null;
            raiz = nuevo;
        }
        else
        {
            nuevo.sig = raiz;
            raiz = nuevo;
        }
    }
    
    public int extraer ()
    {
        if (raiz!=null)
        {
            int informacion = raiz.info;
            raiz = raiz.sig;
            return informacion;
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
    
    public int retornar ()
    {
        if (raiz!=null)
        {
            int informacion = raiz.info;
            return informacion;
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
    
    public void imprimir() {
        Nodo reco=raiz;
        System.out.println("Listado de todos los elementos de la pila.");
        while (reco!=null) {
            System.out.print(reco.info+"-");
            reco=reco.sig;
        }
        System.out.println();
    }
    
    public static void main(String[] ar) {
        Pila pila1=new Pila();
        pila1.insertar(10);
        pila1.insertar(40);
        pila1.insertar(3);
        pila1.imprimir();
        System.out.println("Extraemos de la pila:"+pila1.extraer());
        pila1.imprimir();
        System.out.println("Retornamos primero de la pila:"+pila1.retornar());
        pila1.imprimir();
    }
}
</pre></div>

<table width="700px">
<tr>
<td align="left">	

<script async src="../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
<!-- propuesto-javaya -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-4669394804436935"
     data-ad-slot="1400020364"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
<!-- propuesto-javaya -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-4669394804436935"
     data-ad-slot="1400020364"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</table>

 <br>
   <h2><a href="index1e61.html?inicio=40">Retornar</a></h2>   
 
  </div>
    </div>
  </div>
</div>




</body>


<!-- Mirrored from www.javaya.com.ar/detalleconcepto.php?codigo=115&inicio=40 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 15 Sep 2015 14:54:14 GMT -->
</html>
